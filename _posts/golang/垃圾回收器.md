---
author: djaigo
title: golang-垃圾回收器
categories:
  - golang
date: 2024-01-01 00:00:00
tags:
  - golang
  - 垃圾回收
  - GC
  - 内存管理
---

推荐阅读：[Go Garbage Collector](https://go.dev/src/runtime/mgc.go)

# Golang 垃圾回收器概述

Go 语言的垃圾回收器（Garbage Collector, GC）是一个**并发、三色标记、非分代**的垃圾回收器，能够在程序运行的同时进行垃圾回收，最小化对程序性能的影响。

## 设计目标

1. **低延迟**: 减少 GC 导致的程序停顿时间（STW - Stop The World）
2. **高吞吐**: 在保证低延迟的同时，提高整体性能
3. **并发执行**: GC 与程序并发运行，减少对业务的影响
4. **自动管理**: 无需手动管理内存，减少内存泄漏风险

## 核心特性

- **并发标记**: GC 标记阶段与程序并发执行
- **三色标记算法**: 使用三色标记法追踪可达对象
- **写屏障（Write Barrier）**: 保证并发标记的正确性
- **增量清扫**: 将清扫工作分散到多个 GC 周期
- **非分代**: 不区分新生代和老生代

# GC 核心算法

## 三色标记算法

三色标记算法是 Go GC 的核心算法，它将对象标记为三种颜色：

```
白色（White）: 未被访问的对象（可能是垃圾）
灰色（Gray）: 已被访问，但其引用的对象还未被扫描
黑色（Black）: 已被访问，且其引用的对象都已被扫描
```

### 标记过程

```
初始状态:
    所有对象都是白色

标记根对象:
    根对象（全局变量、栈变量等）标记为灰色
    ┌─────────┐
    │ 根对象   │ → 灰色
    └─────────┘

扫描灰色对象:
    1. 将灰色对象标记为黑色
    2. 将其引用的白色对象标记为灰色
    3. 重复直到没有灰色对象
    
    ┌─────────┐      ┌─────────┐
    │ 对象A   │ ───→ │ 对象B   │
    │ (黑色)  │      │ (灰色)  │
    └─────────┘      └─────────┘
                          │
                          ↓
                     ┌─────────┐
                     │ 对象C   │
                     │ (白色)  │ → 垃圾
                     └─────────┘

最终状态:
    黑色对象 = 存活对象
    白色对象 = 垃圾对象（可回收）
```

### 三色标记示例

```
初始状态（所有对象都是白色）:
    Root → A(白) → B(白) → C(白)
           │
           └→ D(白)

标记根对象（Root 引用的对象变灰）:
    Root → A(灰) → B(白) → C(白)
           │
           └→ D(白)

扫描 A（A 变黑，A 引用的对象变灰）:
    Root → A(黑) → B(灰) → C(白)
           │
           └→ D(灰)

扫描 B（B 变黑，B 引用的对象变灰）:
    Root → A(黑) → B(黑) → C(灰)
           │
           └→ D(灰)

扫描 C 和 D（都变黑）:
    Root → A(黑) → B(黑) → C(黑)
           │
           └→ D(黑)

结果:
    - 黑色对象（A, B, C, D）: 存活，需要保留
    - 白色对象: 不存在，说明没有垃圾
```

## 并发标记的挑战

在并发标记过程中，程序可能修改对象之间的引用关系，导致标记错误：

### 问题场景：丢失标记

```
时刻 T1: GC 扫描完成
    Root → A(黑) → B(黑)
           │
           └→ C(白)  // C 是垃圾

时刻 T2: 程序修改引用（在 GC 标记过程中）
    A.next = C  // A 现在引用 C
    B.next = nil  // B 不再引用 C

时刻 T3: GC 完成标记
    Root → A(黑) → C(白)  // C 被误判为垃圾！
           │
           └→ B(黑)
```

**问题**: C 对象实际上被 A 引用了，但因为标记时是白色，被误判为垃圾。

### 解决方案：写屏障（Write Barrier）

写屏障在对象引用关系改变时，将被引用的对象标记为灰色，确保不会丢失标记。

```
写屏障规则:
    如果黑色对象引用白色对象，将白色对象标记为灰色

时刻 T1: GC 扫描完成
    Root → A(黑) → B(黑)
           │
           └→ C(白)

时刻 T2: 程序修改引用
    A.next = C  // 写屏障触发
    // 写屏障: 因为 A(黑) 引用 C(白)，将 C 标记为灰

时刻 T3: GC 继续扫描
    Root → A(黑) → C(灰)  // C 被正确标记
           │
           └→ B(黑)

时刻 T4: GC 完成
    Root → A(黑) → C(黑)  // C 被正确保留
           │
           └→ B(黑)
```

# GC 核心组件

## 1. GC 工作器（GC Worker）

GC 工作器是执行标记和清扫任务的 goroutine。

### 结构定义（简化）

```go
type gcWork struct {
    // 工作缓冲区
    wbuf1, wbuf2 *workbuf
    
    // 标记队列
    bytesMarked uint64
    scanWork    int64
}
```

### GC 工作器的作用

1. **标记对象**: 扫描灰色对象，标记其引用的对象
2. **并行工作**: 多个工作器并行标记，提高效率
3. **工作窃取**: 工作器可以窃取其他工作器的工作

## 2. 标记队列（Mark Queue）

标记队列用于存储待扫描的灰色对象。

```
标记队列:
┌──────┬──────┬──────┬──────┐
│ 对象A │ 对象B │ 对象C │ 对象D │  ← 灰色对象队列
└──────┴──────┴──────┴──────┘
   │      │      │      │
   └──────┴──────┴──────┘
          ↓
      工作器扫描
```

### 工作流程

```
1. 根对象入队（变灰）
2. 工作器从队列取出对象（变黑）
3. 扫描对象引用的其他对象（变灰）
4. 将新发现的灰色对象入队
5. 重复直到队列为空
```

## 3. 写屏障（Write Barrier）

写屏障在对象引用改变时触发，确保并发标记的正确性。

### 插入写屏障（Insert Write Barrier）

```go
// 伪代码
func writebarrierptr(dst *unsafe.Pointer, src unsafe.Pointer) {
    // 如果 dst 是黑色对象，src 是白色对象
    if isBlack(dst) && isWhite(src) {
        // 将 src 标记为灰色
        shade(src)
    }
    // 执行实际的写操作
    *dst = src
}
```

### 写屏障类型

Go 1.8+ 使用**混合写屏障**（Hybrid Write Barrier），结合了插入写屏障和删除写屏障的优点。

## 4. 根对象扫描器（Root Scanner）

根对象是 GC 的起点，包括：

```
根对象类型:
├─ 全局变量
├─ 栈变量（所有 goroutine 的栈）
├─ 寄存器变量
└─ 其他运行时数据结构
```

### 根扫描流程

```
1. 扫描全局变量
   └─→ 标记为灰色

2. 扫描所有 goroutine 的栈
   └─→ 标记栈上的变量为灰色

3. 扫描寄存器
   └─→ 标记寄存器中的变量为灰色

4. 扫描其他运行时数据
   └─→ 标记为灰色
```

## 5. 清扫器（Sweeper）

清扫器负责回收标记为白色的对象（垃圾）。

### 清扫流程

```
1. 扫描所有 span
2. 找出标记为白色的对象
3. 将对象内存标记为空闲
4. 如果 span 完全空闲，归还给 mheap
```

### 增量清扫

Go 使用增量清扫，将清扫工作分散到多个 GC 周期：

```
GC 周期 1: 清扫部分内存
GC 周期 2: 继续清扫剩余内存
GC 周期 3: 完成清扫
```

# GC 执行流程

## 完整的 GC 周期

```
┌─────────────────────────────────────────┐
│         GC 周期开始                      │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   阶段 1: 准备阶段（STW）                │
│   - 停止所有 goroutine                   │
│   - 扫描栈，启用写屏障                    │
│   - 准备标记队列                         │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   阶段 2: 标记阶段（并发）               │
│   - 启动 GC 工作器                       │
│   - 恢复 goroutine 运行                  │
│   - 并发标记对象                         │
│   - 写屏障保护                           │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   阶段 3: 标记终止（STW）                │
│   - 停止所有 goroutine                   │
│   - 完成最后的标记工作                    │
│   - 关闭写屏障                           │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   阶段 4: 清扫阶段（并发）               │
│   - 恢复 goroutine 运行                  │
│   - 并发清扫垃圾对象                     │
│   - 归还空闲内存                         │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│         GC 周期结束                      │
└─────────────────────────────────────────┘
```

## 详细流程说明

### 阶段 1: 准备阶段（STW - Stop The World）

```go
// 伪代码
func gcStart() {
    // 1. 停止所有 goroutine（STW）
    stopTheWorld()
    
    // 2. 扫描所有 goroutine 的栈
    scanStacks()
    
    // 3. 启用写屏障
    enableWriteBarrier()
    
    // 4. 初始化标记队列
    initMarkQueue()
    
    // 5. 标记根对象为灰色
    markRoots()
}
```

**STW 时间**: 通常 < 1ms

### 阶段 2: 标记阶段（并发）

```go
// 伪代码
func concurrentMark() {
    // 1. 启动 GC 工作器
    for i := 0; i < numGCWorkers; i++ {
        go gcWorker()
    }
    
    // 2. 恢复 goroutine 运行
    startTheWorld()
    
    // 3. 工作器并发标记
    // - 从标记队列取出灰色对象
    // - 扫描对象引用的其他对象
    // - 将新发现的灰色对象入队
    // - 写屏障保护并发安全
}
```

**并发执行**: GC 与程序同时运行

### 阶段 3: 标记终止（STW）

```go
// 伪代码
func markTermination() {
    // 1. 停止所有 goroutine（STW）
    stopTheWorld()
    
    // 2. 完成最后的标记工作
    drainMarkQueue()
    
    // 3. 关闭写屏障
    disableWriteBarrier()
    
    // 4. 计算需要清扫的内存
    calculateSweepWork()
}
```

**STW 时间**: 通常 < 1ms

### 阶段 4: 清扫阶段（并发）

```go
// 伪代码
func concurrentSweep() {
    // 1. 恢复 goroutine 运行
    startTheWorld()
    
    // 2. 并发清扫
    // - 扫描所有 span
    // - 回收白色对象（垃圾）
    // - 归还空闲内存
    // - 增量执行，不一次性完成
}
```

**增量执行**: 清扫工作分散到多个周期

# GC 触发条件

## 1. 自动触发

GC 会在以下情况自动触发：

### 堆内存增长触发

```
当前堆内存 = 上次 GC 后的堆内存 × (1 + GOGC/100)

例如: GOGC = 100
    当前堆内存 = 上次堆内存 × 2
    当堆内存增长 100% 时触发 GC
```

### 代码触发

```go
// 手动触发 GC
runtime.GC()

// 设置 GC 目标百分比
debug.SetGCPercent(100)  // 默认 100
```

## 2. 强制触发

### 内存限制触发

```go
// Go 1.19+ 支持内存限制
debug.SetMemoryLimit(2 * 1024 * 1024 * 1024)  // 2GB

// 当内存使用超过限制时，强制触发 GC
```

### 系统压力触发

当系统内存压力大时，Go 会主动触发更频繁的 GC。

## 3. 定时触发

Go 运行时可能会定时触发 GC，确保内存及时回收。

# GC 性能指标

## 关键指标

### 1. GC 频率（GC Frequency）

```
GC 频率 = GC 次数 / 运行时间

频率过高: 可能内存分配过快
频率过低: 可能内存使用过多
```

### 2. GC 暂停时间（GC Pause Time）

```
STW 时间 = 准备阶段时间 + 标记终止时间

目标: < 1ms（通常 < 0.5ms）
```

### 3. GC CPU 占用（GC CPU Usage）

```
GC CPU 占用 = GC 使用的 CPU 时间 / 总 CPU 时间

目标: < 25%
```

### 4. 堆内存使用（Heap Usage）

```
堆内存使用 = 当前堆内存 / 最大堆内存

目标: 合理使用，避免过度分配
```

## 查看 GC 统计信息

### 方式 1: 使用 GODEBUG

```bash
# 设置环境变量
export GODEBUG=gctrace=1

# 运行程序
go run main.go
```

**输出示例：**
```
gc 1 @0.001s 2%: 0.010+0.20+0.002 ms clock, 0.040+0.20/0.10/0.20+0.008 ms cpu, 4->4->0 MB, 5 MB goal, 4 P
```

**字段说明：**
- `gc 1`: GC 周期编号
- `@0.001s`: 程序运行时间
- `2%`: GC 占用的 CPU 百分比
- `0.010+0.20+0.002 ms`: STW 时间（准备+标记终止+其他）
- `4->4->0 MB`: 堆内存变化（GC前->GC后->存活对象）
- `5 MB goal`: GC 目标堆大小
- `4 P`: 使用的 P 数量

### 方式 2: 使用 runtime.ReadMemStats

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    var m1, m2 runtime.MemStats
    
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    // 执行代码
    data := make([]byte, 1024*1024)
    _ = data
    
    runtime.GC()
    runtime.ReadMemStats(&m2)
    
    fmt.Printf("GC 次数: %d\n", m2.NumGC-m1.NumGC)
    fmt.Printf("GC 暂停时间: %v\n", time.Duration(m2.PauseTotalNs-m1.PauseTotalNs))
    fmt.Printf("堆内存: %d KB\n", m2.HeapAlloc/1024)
}
```

### 方式 3: 使用 pprof

```bash
# 获取 GC 统计
go tool pprof http://localhost:6060/debug/pprof/heap

# 查看 GC 相关信息
(pprof) top
(pprof) list 函数名
```

# GC 调优参数

## 1. GOGC 参数

控制 GC 的触发频率：

```bash
# 默认值：100
# 表示：当堆内存增长 100% 时触发 GC
export GOGC=100

# 更积极的 GC（更频繁，内存使用更少）
export GOGC=50   # 增长 50% 就触发

# 更宽松的 GC（更少 GC，内存使用更多）
export GOGC=200  # 增长 200% 才触发

# 禁用自动 GC（不推荐）
export GOGC=off
```

### GOGC 的影响

```
GOGC = 50:
    - GC 更频繁
    - 内存使用更少
    - CPU 占用可能更高
    - 适合内存受限环境

GOGC = 100 (默认):
    - 平衡内存和 CPU
    - 适合大多数场景

GOGC = 200:
    - GC 更少
    - 内存使用更多
    - CPU 占用可能更低
    - 适合内存充足环境
```

## 2. GOMEMLIMIT 参数

设置内存使用上限（Go 1.19+）：

```bash
# 设置最大内存使用为 2GB
export GOMEMLIMIT=2GiB

# 设置最大内存使用为 512MB
export GOMEMLIMIT=512MiB

# 禁用内存限制（默认）
export GOMEMLIMIT=0
```

### GOMEMLIMIT 的影响

```
设置 GOMEMLIMIT:
    - 防止程序使用过多内存
    - 超过限制时强制触发 GC
    - 可能导致更频繁的 GC
    - 适合容器环境
```

## 3. 其他环境变量

```bash
# GC 调试信息
export GODEBUG=gctrace=1

# 设置 GC 目标百分比（代码中）
debug.SetGCPercent(100)

# 设置内存限制（代码中）
debug.SetMemoryLimit(2 * 1024 * 1024 * 1024)
```

# GC 优化策略

## 1. 减少内存分配

### 使用对象池

```go
package main

import (
    "sync"
)

var pool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func main() {
    // 从池中获取
    buf := pool.Get().([]byte)
    defer pool.Put(buf) // 归还到池中
    
    // 使用 buf
    // ...
}
```

### 预分配切片容量

```go
// 不好：频繁扩容，增加 GC 压力
var s []int
for i := 0; i < 1000; i++ {
    s = append(s, i)
}

// 好：预分配容量
s := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    s = append(s, i)
}
```

## 2. 减少指针使用

### 使用值类型

```go
// 小结构体使用值类型
type Point struct {
    X, Y int
}

// 值类型：在栈上分配，无需 GC
func useValue(p Point) {
    // ...
}

// 指针类型：在堆上分配，需要 GC
func usePointer(p *Point) {
    // ...
}
```

### 使用数组而非切片

```go
// 固定大小使用数组
var arr [100]int  // 栈上分配

// 动态大小使用切片
var slice []int   // 堆上分配
```

## 3. 优化数据结构

### 减少嵌套指针

```go
// 不好：深层指针嵌套
type Node struct {
    Children []*Node  // 指针数组
}

// 好：使用索引
type Node struct {
    Children []int  // 索引数组
}
```

### 使用结构体数组

```go
// 不好：指针数组
type Nodes []*Node

// 好：值数组
type Nodes []Node
```

## 4. 合理设置 GC 参数

### 根据场景调整 GOGC

```go
// 内存受限环境
os.Setenv("GOGC", "50")

// 内存充足环境
os.Setenv("GOGC", "200")

// 容器环境
os.Setenv("GOMEMLIMIT", "512MiB")
```

## 5. 监控 GC 性能

### 定期检查 GC 统计

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func monitorGC() {
    var m runtime.MemStats
    for {
        runtime.ReadMemStats(&m)
        fmt.Printf("GC 次数: %d\n", m.NumGC)
        fmt.Printf("GC 暂停时间: %v\n", time.Duration(m.PauseTotalNs))
        fmt.Printf("堆内存: %d MB\n", m.HeapAlloc/1024/1024)
        time.Sleep(5 * time.Second)
    }
}
```

# GC 与内存分配器的协作

## 协作流程

```
内存分配
    ↓
mcache/mcentral/mheap
    ↓
对象使用中
    ↓
GC 标记阶段
    ├─→ 扫描 mcache 中的对象
    ├─→ 扫描 mcentral 中的对象
    └─→ 扫描 mheap 中的对象
    ↓
标记存活对象（黑色）
    ↓
GC 清扫阶段
    ├─→ 回收未标记对象（白色）
    ├─→ 将空闲 span 归还 mheap
    └─→ 更新 mcache/mcentral
    ↓
内存可复用
```

## 标记阶段与分配器的交互

```
分配对象时:
    1. 从 mcache 分配
    2. 如果对象被根对象引用，写屏障会标记

GC 标记时:
    1. 扫描 mcache 中的对象
    2. 标记可达对象
    3. 更新对象的标记位
```

## 清扫阶段与分配器的交互

```
GC 清扫时:
    1. 扫描所有 span
    2. 回收白色对象（垃圾）
    3. 如果 span 完全空闲，归还 mheap
    4. 如果 span 部分空闲，放回 mcentral
    5. mcache 可以复用这些 span
```

# 常见问题与解决方案

## 1. GC 暂停时间过长

### 问题表现

```
GC 暂停时间 > 10ms
程序响应变慢
用户体验差
```

### 解决方案

1. **减少内存分配**
   ```go
   // 使用对象池
   // 预分配容量
   // 减少指针使用
   ```

2. **调整 GOGC 参数**
   ```bash
   # 更频繁的 GC，但每次处理更少
   export GOGC=50
   ```

3. **优化数据结构**
   ```go
   // 减少指针嵌套
   // 使用值类型
   // 减少对象大小
   ```

## 2. GC CPU 占用过高

### 问题表现

```
GC CPU 占用 > 50%
整体性能下降
CPU 资源浪费
```

### 解决方案

1. **减少内存分配**
   - 使用对象池
   - 复用缓冲区
   - 减少临时对象

2. **调整 GOGC 参数**
   ```bash
   # 更宽松的 GC
   export GOGC=200
   ```

3. **优化代码**
   - 减少不必要的分配
   - 使用更高效的数据结构

## 3. 内存使用过多

### 问题表现

```
堆内存持续增长
可能触发 OOM
内存使用率低
```

### 解决方案

1. **调整 GOGC 参数**
   ```bash
   # 更积极的 GC
   export GOGC=50
   ```

2. **设置内存限制**
   ```bash
   export GOMEMLIMIT=2GiB
   ```

3. **检查内存泄漏**
   ```bash
   # 使用 pprof 对比不同时间点的 heap
   go tool pprof -base heap1.prof heap2.prof
   ```

## 4. GC 频率过高

### 问题表现

```
GC 频率 > 10次/秒
程序性能下降
CPU 占用高
```

### 解决方案

1. **减少内存分配速度**
   - 使用对象池
   - 批量处理
   - 减少临时对象

2. **调整 GOGC 参数**
   ```bash
   # 允许更多内存增长
   export GOGC=200
   ```

3. **优化代码**
   - 减少不必要的分配
   - 复用对象

# 实际应用示例

## 示例 1: 监控 GC 性能

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    // 启动监控
    go monitorGC()
    
    // 模拟工作负载
    for i := 0; i < 1000; i++ {
        data := make([]byte, 1024*1024)
        _ = data
        time.Sleep(100 * time.Millisecond)
    }
}

func monitorGC() {
    var lastNumGC uint32
    var lastPauseTotalNs uint64
    
    for {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        if lastNumGC > 0 {
            numGC := m.NumGC - lastNumGC
            pauseTotal := m.PauseTotalNs - lastPauseTotalNs
            
            if numGC > 0 {
                avgPause := time.Duration(pauseTotal) / time.Duration(numGC)
                fmt.Printf("GC 次数: %d, 平均暂停: %v, 堆内存: %d MB\n",
                    numGC, avgPause, m.HeapAlloc/1024/1024)
            }
        }
        
        lastNumGC = m.NumGC
        lastPauseTotalNs = m.PauseTotalNs
        time.Sleep(5 * time.Second)
    }
}
```

## 示例 2: 优化内存分配

```go
package main

import (
    "sync"
)

// 使用对象池减少分配
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}

func processData(data []byte) {
    // 从池中获取缓冲区
    buf := bufferPool.Get().([]byte)
    defer bufferPool.Put(buf[:0]) // 归还到池中，重置长度
    
    // 使用缓冲区
    buf = append(buf, data...)
    // 处理数据...
    _ = buf
}
```

## 示例 3: 调整 GC 参数

```go
package main

import (
    "runtime/debug"
    "os"
)

func main() {
    // 根据环境调整 GC
    if os.Getenv("ENV") == "production" {
        // 生产环境：平衡内存和性能
        debug.SetGCPercent(100)
        debug.SetMemoryLimit(2 * 1024 * 1024 * 1024) // 2GB
    } else {
        // 开发环境：更积极的 GC
        debug.SetGCPercent(50)
    }
    
    // 业务代码...
}
```

# 总结

Go 垃圾回收器的核心特点：

1. **并发执行**: GC 与程序并发运行，减少停顿时间
2. **三色标记**: 使用三色标记算法追踪可达对象
3. **写屏障保护**: 确保并发标记的正确性
4. **低延迟**: STW 时间通常 < 1ms
5. **自动管理**: 无需手动管理内存

**GC 流程：**

```
准备阶段（STW） → 标记阶段（并发） → 标记终止（STW） → 清扫阶段（并发）
```

**核心组件：**

- **GC 工作器**: 执行标记和清扫任务
- **标记队列**: 存储待扫描的灰色对象
- **写屏障**: 保护并发标记的正确性
- **根扫描器**: 扫描根对象
- **清扫器**: 回收垃圾对象

**优化建议：**

1. 减少内存分配（对象池、预分配）
2. 减少指针使用（值类型、数组）
3. 合理设置 GC 参数（GOGC、GOMEMLIMIT）
4. 监控 GC 性能（GODEBUG、pprof）
5. 优化数据结构（减少嵌套、使用值类型）

理解 Go GC 的工作原理，有助于编写高性能的 Go 程序，减少 GC 压力，提高程序性能。

