---
author: djaigo
title: linux-shell语法
categories:
  - golang
date: 2022-10-21 15:12:33
tags:
  - shell
---

# 变量
语法`a=b`，`a`为变量名，`b`为变量值。
让其他函数输出作为变量
```sh
a=$(ls)
# 或者使用反引号
a=`ls`
```

命名规则，变量名只能由字母数字下划线组成，且不能是数字开头，且不能是shell里面的关键字。
使用变量，使用`$`表示取变量值，为了具体变量名可以用`{}`括起来，防止引发歧义。

## 变量类型
运行shell时，会同时存在三种变量：
* 局部变量，局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
* 环境变量，所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
*  shell变量，shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

## 变量修饰符
可以用相关修饰符控制变量的某些属性：
* `export`标记导出变量，便于其他shell文件使用当前变量
* `readonly`标记可以将变量变成只读变量
* `unset`标记删除变量

## 字符串
shell字符串，用单引号或双引号描述
* 单引号表示纯字符串，会将内容完全看成字符串
* 双引号表示字符串中可以使用变量，也支持转义字符
* 两者可以交叉使用，以最外层的引号为基准，进行字符串语义识别

### 字符串操作
* 拼接，将字符串写在一起即可表示拼接字符串
* 获取长度，使用`${#str}`获取字符串`str`的长度
* 截取子串，使用`${str:1:3}`截取字符串`str`的第二个字符到第4个字符（索引从0开始，截取区间左闭右闭）

字符串匹配截断
* `${var##*/}`，去掉变量var从左边算起的最后一个'/'字符及其左边的内容，返回从左边算起的最后一个'/'（不含该字符）的右边的内容。
* `${var#*.}`，去掉变量var从左边算起的第一个'.'字符及其左边的内容，返回从左边算起第一个'.'（不含该字符）的右边部分的内容。
* `${var%/*}`，去掉变量var从右边算起的第一个'/'字符及其右边的内容，返回从右边算起的第一个'/'（不含该字符）的左边的内容。
* `${var%%.*}`，去掉变量var从右边算起的最后一个'.'字符及其右边的内容，返回从右边算起的最后一个'.'（不含该字符）的左边的内容。

${}并不是专门为提取文件名或目录名的，它的使用是变量的提取和替换等等操作，它可以提取非常多的内容，并不一定是上面五个例子中的'/'或'.'。
* `#`：表示从左边算起第一个
* `%`：表示从右边算起第一个
* `##`：表示从左边算起最后一个
* `%%`：表示从右边算起最后一个
换句话来说，`＃`总是表示左边算起，`％`总是表示右边算起。

`＊`：表示要删除的内容，对于#和##的情况，它位于指定的字符（例子中的`/`和`.`）的左边，表于删除指定字符及其左边的内容；对于`%`和`%%`的情况，它位于指定的字符（例子中的`/`和`.`）的右边，表示删除指定字符及其右边的内容。这里的`*`的位置不能互换，即不能把`*`号放在`#`或`##`的右边，反之亦然。

例如：`${var%%x*}`表示找出从右边算起最后一个字符x，并删除字符x及其右边的字符。

## 数组
shell数组，用圆括号括起多个元素，即为数组。
* 通过方括号取对应索引的值，可以用数字下标获取（从0开始），`${array[0]}`
* `@`或`*`表示数组中所有元素，`${array[@]}`，`${array[*]}`
* `#`表示获取数组长度，配合`@`可以获取数组长度，`${#array[@]}`

# 参数
获取传入参数
* `$#`，传入参数个数
* `$*`，传入所有参数列表，如果用双引号则表示`"$1 $2 ... $n"`
* `$$`，当前脚本运行进程号
* `$!`，后台运行第一个进程号
* `$@`，与`$*`类似，用双引号表示`"$1" "$2" ... "$n"`
* `$-`，显示当前shell使用的选项
* `$?`，上一个shell语句的退出码

# 条件判断
## if
语法
```sh
if [ c1 ]; then
elif [ c2 ]; then
else
fi
```
使用条件判断语句，每个条件使用方括号`[]`包含，也可用双圆括号包含`(())`，双圆括号能够识别大于小于符号语义，**如果方括号使用大于小于符号则会被认为是输入输出重定向，条件用于为真**。
```sh
if [ "$a" -gt "$b" ]; then
    ...
fi

if (( $a > $b )); then
    ...
fi
```


### 判断命令
在方括号中可以使用的快速判断函数
* `-a`（`and`）条件与
* `-b`（`block`）是否是块设备
* `-c`（`char`）是否是字符设备
* `-d`（`dir`）是否是文件夹
* `-e`（`exist`）文件目录是否存在
* `-eq`（`equal`）相等
* `-f`（`file`）是否是文件
* `-g`是否设置了SGID位
* `-ge`（`greate then or equal`）大于等于
* `-gt`（`greate then`）大于
* `-k`是否设置了粘置位（Sticky Bit）
* `-le`（`less then or equal`）小于等于
* `-lt`（`less then`）小于
* `-n`（`not zero`）字符串长度是否不为0
* `-ne`（`not equal`）不相等
* `-o`（`or`）条件或
* `-r`（`read`）文件是否可读
* `-s`文件是否为空
* `-p`（`pipe`）是否是管道
* `-u`是否设置了suid
* -`w`（`write`）文件是否可写
* `-x`文件是否可执行
* `-z`（`zero`）字符串长度是否为0
* `==`变量是否相等
* `!=`变量是否不相等
* `!`条件取反
* `$`变量是否空

## case
语法
```sh
case $cmd in
  cmd1)
  ;;
  cmd2)
  ;;
  *)
  ;;
esac
```

* `;;`表示执行后退出case
* `*`表示通配符


# 循环
## for
语法
```sh
# 遍历模式
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done

# 索引模式
for(( i=0;i < N;i++ ))
do
    command1
    command2
    ...
    commandN
done
```

## while
条件为真时执行
语法
```sh
while condition
do
    command
done
```

## until
执行一直到条件为真时停止
语法
```sh
until condition
do
    command
done
```

## break
终止本次循环并且跳出循环
## continue
终止本次循环开始下次循环


# 函数
使用`function`表示函数，参数由`$`获取，参数使用与上述参数使用方式相同。
语法
```sh
[ function ] funname [()]
{
    action;
    [return int;]
}
```

其中函数表示`function`可以省略，函数参数标识圆括号也可省略，即可以直接用`funcname{}`也可。